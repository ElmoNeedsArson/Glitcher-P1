<!DOCTYPE html>
<html>

<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quantico:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">
    <meta charset="UTF-8">
    <!-- Ensures proper scaling on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Object Detection Full-Screen (Cover Mode)</title>
    <!-- Load TensorFlow.js and the COCO-SSD model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000000;
            font-family: "Quantico", sans-serif;
            font-weight: 700;
            font-style: normal;
            /* height: 100%;
        width: 100%; */
        }

        /* Canvas is set to fill the viewport */
        #canvas {
            display: block;
            /* width: 100vw;
        height: 100vh; */
        }

        #glitchCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }

        #video {
            width: 100vh;
        }

        #startButton {
            /* font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif; */
            font-family: "Quantico", sans-serif;
            font-weight: 700;
            font-style: normal;
            position: absolute;
            border: none;
            bottom: 5px;
            right: 5px;
            z-index: 10;
            padding: 10px 20px;
            font-size: 16px;
            margin-top: 10px;
            background-color: rgb(255, 255, 255);
        }

        #container1 {
            display: flex;
            width: 100vw;
            align-items: center;
            align-content: center;
        }

        #heading {
            font-family: 'League Spartan', sans-serif;
            font-weight: bold;
            text-align: center;
            padding-top: 20px;
            width: 100vw;
            /* position: absolute;
      width: 100vw;
      top: 10px;
      z-index: 10; */
            font-size: 32px;
        }

        #icon {
            width: 50px;
            height: 50px;
            background-image: url(dots.png);
            background-size: contain;
            background-repeat: no-repeat;
            position: absolute;
            top: 50vh;
            right: 10px;
        }

        #portal {
            display: flex;
            margin-top: 20px;
            width: 80vw;
            height: 60vh;
            background-color: #bd0000;
            margin-left: auto;
            margin-right: auto;
        }

        #portal1 {
            font-family: "Quantico", sans-serif;
            font-weight: 700;
            font-style: normal;
            margin: 10px;
            padding: 10px;
            width: 100%;
            border: 6px white;
            border-style: double;
            color: white;
            font-size: 20px;
            position: relative;
        }

        #title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.5);
            display: none;
            animation: blink 0.3s ease-out;
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            100% {
                opacity: 0;
            }
        }

        #errorOverlay {
            display: none;
            /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #00008B;
            /* Windows blue screen color */
            color: white;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px;
            padding-top: 20vh;
            z-index: 99999;
        }
    </style>
</head>

<body>
    <!-- <div id="heading">AIBPO Solutions</div> -->
    <div id="title">WAIT A BIT...</div>
    <div id="container1"></div>
    <div id="icon"></div>
    <div id="portal">
        <div id="portal1">
            INSTRUCTIONS:<br>
            1) COLLECT.
            <button id="startButton">START!</button>
        </div>
    </div>
    <!-- Hidden video element -->
    <video id="video" autoplay muted playsinline style="display: none;"></video>
    <!-- Canvas for drawing (covering the entire viewport) -->
    <canvas id="canvas"></canvas>
    <!-- <canvas id="glitchCanvas"></canvas> -->
    <audio id="hurrayAudio" src="ding.mp3" preload="auto"></audio>
    <div id="overlay"></div>
    <div id="moreText"
        style="display: none; font-size: 50px; font-weight: bold; color: red; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999;">
        MORE
    </div>

    <div id="errorOverlay">
        <h1>ðŸ’€ SYSTEM ERROR ðŸ’€</h1>
        <p>A fatal error has occurred. System shutdown initiated.</p>
        <p>Technical details: <span style="color: yellow;">ERROR CODE: 0xDEADCAFE</span></p>
        <p>Contact system administrator.</p>
        <p>Press CTRL+ALT+DEL to restart (not really).</p>
    </div>


    <script>
        let model;
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        //const glitchCanvas = document.getElementById('glitchCanvas');
        const ctx = canvas.getContext('2d');
        //const glitchCtx = glitchCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const title = document.getElementById('title');

        const hurrayAudio = document.getElementById('hurrayAudio'); // Get the audio element

        const port = document.getElementById('portal')
        const port1 = document.getElementById('portal1')

        const overlay = document.getElementById('overlay');

        // Variables for person detection alerting.
        let lastPersonTime = Date.now();
        let personInView = false;
        let alarmInterval = null;

        const itemsToFind = ["person", "remote", "cell phone"];
        let currentItems = [];
        let currentIndex = 0;

        function updateTitle() {
            currentIndex = Math.min(currentIndex + 1, itemsToFind.length);
            currentItems = itemsToFind.slice(0, currentIndex);
            title.innerText = `FIND ${currentItems.join(', ')}!`;
        }

        function startItemSequence() {
            updateTitle();
            let interval = setInterval(() => {
                if (currentIndex < itemsToFind.length) {
                    updateTitle();
                } else {
                    clearInterval(interval);
                }
            }, 30000);
        }

        // Set up the webcam feed with improved resolution constraints.
        async function setupCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });
                video.srcObject = stream;
                return new Promise(resolve => {
                    video.onloadedmetadata = () => resolve(video);
                });
            } else {
                alert("Webcam not available.");
            }
        }

        // Adjust canvas size to fill the window and set the proper drawing scale.
        function adjustCanvasSize() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;
            // const availableWidth = window.innerWidth;
            // const availableHeight = window.innerHeight;
            // Set the canvas's internal resolution.
            // canvas.width = availableWidth * dpr;
            // canvas.height = availableHeight * dpr;
            // // Set the displayed size via CSS.
            // canvas.style.width = availableWidth + "px";
            // canvas.style.height = availableHeight + "px";
            // ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            [canvas].forEach(c => {
                c.width = width * dpr;
                c.height = height * dpr;
                c.style.width = width + "px";
                c.style.height = height + "px";
            });
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            //glitchCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // 2 seconds cooldown
        const lastPlayedMap = new Map(); // Stores last played timestamp for each object
        function getRandomCooldown() {
            return Math.floor(Math.random() * (3000 - 800 + 1)) + 1500; // Random between 800-2000 ms
        }

        function playAudioForObject(objectClass) {
            if (audioDisabled) {
                console.warn("Audio playback is disabled.");
                return;
            }
            const now = Date.now();
            const cooldown = getRandomCooldown(); // Generate a new cooldown on each detection

            if (!lastPlayedMap.has(objectClass) || now - lastPlayedMap.get(objectClass) > cooldown) {
                if (audioPool.length === 0) {
                    console.warn("No audios available to play.");
                    return;
                }
                // getRandomInt returns a number from 0 (inclusive) to audioPool.length (exclusive)
                let randomIndex = getRandomInt(0, audioPool.length);
                console.log("Random index:", randomIndex);
                const audio = new Audio(audioPool[randomIndex]);
                audio.play();
                lastPlayedMap.set(objectClass, now); // Update last played time
                console.log("Audio played for", objectClass);

                // Show the overlay momentarily
                overlay.style.display = "block";
                setTimeout(() => overlay.style.display = "none", 300);
            }
        }

        // Draw the video feed using a "cover" crop and draw bounding boxes.
        function drawFrame(predictions) {
            if (!video.videoWidth || !video.videoHeight) return;
            const canvasWidth = window.innerWidth;
            const canvasHeight = window.innerHeight;
            const videoAspect = video.videoWidth / video.videoHeight;
            const canvasAspect = canvasWidth / canvasHeight;
            let sx, sy, sWidth, sHeight;

            let foundItems = [];

            // Determine crop region from the video for "cover" style:
            if (canvasAspect > videoAspect) {
                // The canvas is wider than the video:
                sWidth = video.videoWidth;
                sHeight = video.videoWidth / canvasAspect;
                sx = 0;
                sy = (video.videoHeight - sHeight) / 2;
            } else {
                // The canvas is taller than the video:
                sHeight = video.videoHeight;
                sWidth = video.videoHeight * canvasAspect;
                sy = 0;
                sx = (video.videoWidth - sWidth) / 2;
            }
            // Draw the cropped video feed to fill the entire canvas.
            ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, canvasWidth, canvasHeight);

            // Draw bounding boxes:
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'red';
            ctx.font = "18px Arial";
            predictions.forEach(prediction => {
                if (prediction.score < 0.5) return;
                if (currentItems.includes(prediction.class) && !foundItems.includes(prediction.class)) {
                    // foundItems.push(prediction.class);
                    // console.log(`Hurray! Found: ${prediction.class}`);
                    // // hurrayAudio.play();
                    // const sound = new Audio('ding-101492.mp3');
                    // sound.play();

                    if (currentItems.includes(prediction.class)) {
                        playAudioForObject(prediction.class); // Play sound with cooldown check
                    }
                }
                // Get box coordinates relative to the video.
                const [x, y, width, height] = prediction.bbox;
                // Adjust coordinates relative to the crop.
                const adjX = x - sx;
                const adjY = y - sy;
                // Scale factors from video crop to canvas.
                const scaleX = canvasWidth / sWidth;
                const scaleY = canvasHeight / sHeight;
                // Transformed bounding box on the canvas.
                const boxX = adjX * scaleX;
                const boxY = adjY * scaleY;
                const boxWidth = width * scaleX;
                const boxHeight = height * scaleY;
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                ctx.fillStyle = 'red';
                ctx.fillText(
                    `${prediction.class} ${(prediction.score * 100).toFixed(1)}%`,
                    boxX,
                    boxY > 10 ? boxY - 5 : 10
                );
            });
            // if (foundItems.length === currentItems.length) {
            //     console.log("Hurray! All items found:", foundItems);
            // }
        }

        // let glitchIntensity = 3; // Start with a base intensity
        // let glitchMax = 25; // Cap the max intensity
        // let glitchGrowth = 1.02;
        // let sizeMultiplier = 1; // This will control glitch size scaling

        // function resetGlitchEffect() {
        //   glitchIntensity = 3; // Reset when a person is detected
        //   sizeMultiplier = 1;
        // }

        // function drawGlitchEffect() {
        //   let rect = glitchCanvas.getBoundingClientRect()
        //   glitchCtx.clearRect(0, 0, rect.width, rect.height);

        //   let maxGlitches = Math.min(glitchIntensity, glitchMax);
        //   sizeMultiplier = Math.min(1 + glitchIntensity / 50, 3);
        //   //console.log(glitchCanvas.width + "|" + glitchCanvas.height)
        //   for (let i = 0; i < maxGlitches / 4; i++) { // Create 6 glitchy fragments
        //     let x = Math.random() * rect.width ;
        //     let y = (Math.random() * 20 - 10) * sizeMultiplier; // Only on edges
        //     let width = Math.random() * 100 + 50 * sizeMultiplier;
        //     let height = Math.random() * 30 + 10 * sizeMultiplier;
        //     let distortion = Math.random() * 20 - 10;
        //     glitchCtx.fillStyle = `rgba(${Math.random() * 255}, 0, ${Math.random() * 255}, 0.6)`;
        //     glitchCtx.fillRect(x + distortion, y, width, height);
        //     glitchCtx.fillRect(x + distortion, rect.height - y, width, height);
        //   }
        //   for (let i = 0; i < maxGlitches / 4; i++) { // Create 6 glitchy fragments
        //     let x = Math.random() * rect.width;
        //     let y = (Math.random() * 20 + rect.height - 20) * sizeMultiplier; // Only on edges
        //     let width = Math.random() * 100 + 50 * sizeMultiplier;
        //     let height = Math.random() * 30 + 10 * sizeMultiplier;
        //     let distortion = Math.random() * 20 - 10;
        //     glitchCtx.fillStyle = `rgba(${Math.random() * 255}, 0, ${Math.random() * 255}, 0.6)`;
        //     glitchCtx.fillRect(x + distortion, y, width, height);
        //     glitchCtx.fillRect(x + distortion, rect.height - y, width, height);
        //   }
        //   for (let i = 0; i < maxGlitches / 4; i++) { // Create 6 glitchy fragments
        //     let x = (Math.random() * 20) * sizeMultiplier;
        //     let y = Math.random() * rect.height; // Only on edges
        //     let width = Math.random() * 10 + 5 * sizeMultiplier;
        //     let height = Math.random() * 100 + 50 * sizeMultiplier;
        //     let distortion = Math.random() * 20 - 10;
        //     glitchCtx.fillStyle = `rgba(${Math.random() * 255}, 0, ${Math.random() * 255}, 0.6)`;
        //     glitchCtx.fillRect(x + distortion, y, width, height);
        //     glitchCtx.fillRect(x + distortion, rect.height - y, width, height);
        //   }
        //   for (let i = 0; i < maxGlitches / 4; i++) { // Create 6 glitchy fragments
        //     let x = (Math.random() * 20 + rect.width - 40);
        //     console.log(x)
        //     let y = Math.random() * rect.height; // Only on edges
        //     let width = Math.random() * 10 + 5 * sizeMultiplier;
        //     let height = Math.random() * 100 + 50 * sizeMultiplier;
        //     let distortion = Math.random() * 20 - 10;
        //     glitchCtx.fillStyle = `rgba(${Math.random() * 255}, 0, ${Math.random() * 255}, 0.6)`;
        //     glitchCtx.fillRect(x + distortion, y, width, height);
        //     glitchCtx.fillRect(x + distortion, rect.height - y, width, height);
        //   }

        //   // **NEW: Add gradual glitches in the center over time**
        //   if (glitchIntensity > 10) { // Delay center glitches until some time has passed
        //     for (let i = 0; i < maxGlitches / 2; i++) {
        //       let x = Math.random() * rect.width;
        //       let y = Math.random() * rect.height;
        //       let width = Math.random() * 40 + 10 * sizeMultiplier;
        //       let height = Math.random() * 20 + 5 * sizeMultiplier;
        //       let distortion = Math.random() * 10 - 5;
        //       glitchCtx.fillStyle = `rgba(${Math.random() * 255}, 0, ${Math.random() * 255}, 0.3)`;
        //       glitchCtx.fillRect(x + distortion, y, width, height);
        //     }
        //   }

        //   // Gradually increase clutter, but slow at first
        //   glitchIntensity *= glitchGrowth;
        // }

        // function startGlitch() {
        //   if (!personInView) {
        //     drawGlitchEffect();
        //     setTimeout(startGlitch, 200);
        //   } else {
        //     glitchCtx.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);
        //     resetGlitchEffect()
        //   }
        // }

        // Start continuous vibration alarm.
        // function startAlarm() {
        //   if (alarmInterval === null && navigator.vibrate) {
        //     alarmInterval = setInterval(() => {
        //       navigator.vibrate([500, 500]); // vibrate 500ms, pause 500ms
        //     }, 1000);
        //     console.log("Alarm started: No person detected for 3 seconds!");
        //   } else if (!navigator.vibrate) {
        //     console.log("No person detected for 3 seconds!");
        //   }
        //   startGlitch();
        // }

        // Stop the vibration alarm.
        // function stopAlarm() {
        //   if (alarmInterval !== null) {
        //     clearInterval(alarmInterval);
        //     alarmInterval = null;
        //     navigator.vibrate(0);
        //     console.log("Person detected: Alarm stopped.");
        //   }
        //   glitchCtx.clearRect(0, 0, glitchCanvas.width, glitchCanvas.height);
        // }

        // Check predictions for a person.
        function checkPersonDetection(predictions) {
            const personDetected = predictions.some(prediction =>
                prediction.class === 'person' && prediction.score > 0.5
            );
            const now = Date.now();
            if (personDetected) {
                if (!personInView) console.log("Person In view!");
                personInView = true;
                lastPersonTime = now;
            }
        }

        // Run object detection and drawing on each frame.
        async function detectFrame() {
            const predictions = await model.detect(video);
            drawFrame(predictions);
            checkPersonDetection(predictions);
            requestAnimationFrame(detectFrame);
        }

        // Main function: set up camera, canvas, load model, and start detection.
        async function main() {
            await setupCamera();
            adjustCanvasSize();
            video.play();
            video.onloadedmetadata = () => {
                //adjustCanvasSize();
            };
            window.addEventListener('resize', adjustCanvasSize);
            model = await cocoSsd.load();
            console.log('COCO-SSD model loaded.');
            detectFrame();
            startItemSequence();
        }

        // Start detection on user click.
        startButton.addEventListener('click', () => {
            startButton.style.display = 'none';
            port.style.display = 'none';
            port1.style.display = 'none';
            title.style.display = 'flex';
            main();
        });

        // Global audio lists
        let baseAudios = [
            "ding.mp3",
            "discord extra slow.mp3",
            "Discord ping slow.mp3",
            "Discord Ping Sound Effect.mp3",
            "sharp ping.mp3"
        ];
        let extraAudios = [
            "Distored Discord.mp3",
            "long distored discord.mp3"
        ];

        // The pool used by the function â€“ initially only base audios.
        let audioPool = [...baseAudios];

        let audioDisabled = false;

        // Utility function to generate a random integer in [min, max)
        function getRandomInt(min, max) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);
            return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
        }

        // Function to remove a specific audio file from the audioPool
        function removeAudioFile(fileName) {
            const index = audioPool.indexOf(fileName);
            if (index > -1) {
                audioPool.splice(index, 1);
                console.log(`Removed ${fileName} from the pool.`);
            }
        }

        // Schedule adding the extra audios at 1 minute (60000 ms)
        setTimeout(() => {
            audioPool.push(...extraAudios);
            console.log("Extra audios added:", extraAudios);
        }, 60000);

        // Schedule gradual removal of base audios over time.
        // Adjust the times (in milliseconds) and filenames as needed.
        setTimeout(() => removeAudioFile("discord extra slow.mp3"), 30000);                   // at 30 seconds
        setTimeout(() => removeAudioFile("Discord ping slow.mp3"), 50000);       // at 80 seconds
        setTimeout(() => removeAudioFile("Discord Ping Sound Effect.mp3"), 80000);         // at 100 seconds
        setTimeout(() => removeAudioFile("sharp ping.mp3"), 110000); // at 140 seconds
        setTimeout(() => removeAudioFile("ding.mp3"), 120000);                // at 120 seconds

        // After 3 minutes (180000 ms), only extra audios should remain (if all removals worked as planned)
        setTimeout(() => {
            console.log("Final audio pool:", audioPool);
        }, 121000);

        setTimeout(() => {
            audioDisabled = true;
            console.log("Audio playback disabled.");
            document.getElementById("errorOverlay").style.display = "block";
        }, 150000);

        setTimeout(() => {
            function flashMoreText() {
                const moreText = document.getElementById("moreText");
                moreText.style.display = "block"; // Show text
                setTimeout(() => {
                    moreText.style.display = "none"; // Hide after 0.4s
                }, 400);
            }

            function startFlashing() {
                flashMoreText();
                const nextInterval = getRandomInt(8000, 10000); // Random 8-10s
                setTimeout(startFlashing, nextInterval); // Schedule next flash
            }

            startFlashing(); // Begin flashing "MORE"
        }, 80000); // Start after 2 minutes
    </script>
</body>

</html>